---
title: "Notes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Notes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(BOSSS)
library(ggplot2)
```

A place to build up notes and examples for a future tutorial-style document.

Note that the method extends trivially to any kind of Bayesian analysis. We just use the hypotheses parameters to describe hyperparameters for the priors we want to simulate under, and use a Bayesian analysis (or freq if using a hybrid approach). This would include a decision-theoretic approach, where the analysis would give us a utility and we would use the expectation of this as an objective to maximise. One difficulty would be avoiding model compilation when using Stan or brms. We could potentially deal with this by storing a pre-compiled model as a file, and then loading and updating it for each iteration.

Note - a Twitter thread on power analysis had a couple of people mentioning the R package simr for power through simulation when using mixed models. So might be worth including that in one of our examples, to save people having to write their own simulation code?

# Examples

For each example, describe the application here but also allow the problem to be loaded in to the app, with seeds set, so the user can follow along themselves?

## Simple two-sample t-test

### Problem

Simulation:
```{r}
sim_trial <- function(design, hypothesis){
  design <- as.numeric(design); hypothesis <- as.numeric(hypothesis)
  n <- design[1]; k <- design[2]
  mu <- hypothesis[1]; var_u <- hypothesis[2]; var_e <- hypothesis[3]
  
  m <- n/k
  s_c <- sqrt(var_u + var_e/m)
  x0 <- stats::rnorm(k, 0, s_c); x1 <- stats::rnorm(k, mu, s_c)
  c(s = stats::t.test(x0, x1)$p.value >= 0.05, p = n, c = k)
}

# For example,
sim_trial(c(300, 30), c(0.3, 0.05, 0.95))

out_dim <- 3
```

Deterministic objective functions:
```{r}
det_obj <- function(design){
    #o <- matrix(design, ncol = 2)[,1:2]
    #c(s = NA, p = o[1], c = o[2])
  cbind(NA, design)
}
```


Design space and hypotheses:
```{r}
design_space <- data.frame(name = c("n", "k"),
                 low = c(50, 5),
                 up = c(500, 50),
                 int = c(TRUE, TRUE))

hypotheses <- data.frame(mu = c(0.3, 0),
                   var_u = c(0.05, 0.05),
                   var_e = c(0.95, 0.95))
```

### Initialisation

Constraints and objectives:

```{r}
constraints <- data.frame(name = "a",
                   out_i = 1,
                   hyp_i = 1,
                   nom = 0.2,
                   delta = 0.975,
                   stoch = TRUE)

objectives <- data.frame(name = c("f1", "f2", "f3"),
                 out_i = c(2, 3, 1),
                 hyp_i = c(1, 1, 1),
                 weight = c(2, 5, 50),
                 stoch = c(FALSE, FALSE, TRUE))

objectives$weight <- objectives$weight/sum(objectives$weight)
objectives$name <- as.character(objectives$name)
```

Initial DoE:

```{r}
size <- 20
N <- 100

DoE <- init_DoE(size, design_space)

DoE <- cbind(DoE, t(apply(DoE, 1, calc_rates, hypotheses=hypotheses, N=N, sim=sim_trial)))
DoE$N <- N

to_model <- data.frame(out_i = c(1),
                       hyp_i = c(1))

mods <- fit_models(DoE, to_model, design_space, objectives, out_dim)
models <- mods[1]
models_reint <- mods[2]

pf <- pareto_front(design_space, models, DoE, objectives, constraints, to_model, det_obj)
```

### Iteration

```{r}
traj <- NULL

for(i in 1:3){
  ptm <- proc.time()
  opt <- RcppDE::DEoptim(ehi_infill, lower=design_space$low, upper=design_space$up,
                                 control=list(trace=FALSE, itermax=100, reltol=1e-1, steptol=50),
                                 N=N, pf=pf, mod=mods, design_space=design_space, constraints=constraints,
                                 objectives=objectives, det_obj=det_obj, out_dim=3, to_model=to_model)
  sol <- as.numeric(opt$optim$bestmem)
  sol[1:2] <- round(sol[1:2])
  print(proc.time() - ptm)
          
  y <- calc_rates(sol, hypotheses=hypotheses, N=N, sim=sim_trial)
  
  DoE <- rbind(DoE, c(sol, y, N))
  
  models <- fit_models(DoE, to_model, design_space, objectives, out_dim)
  
  pf <- pareto_front(design_space, models, DoE, objectives, constraints, to_model, det_obj)
  
  ref <- c(design_space$up, 1)*objectives$weight
  current <- emoa::dominated_hypervolume(t(pf), ref)
  traj <- rbind(traj, c(-opt$optim$bestval, current))
}
```

### Presentation

```{r}
if(ncol(pf) == 2){
  df <- data.frame(pf)
  ggplot(df, aes(x=X1, y=X2)) + geom_point()
} else if(ncol(pf) == 3){
  df <- data.frame(pf)
  ggplot(df, aes(x=X1, y=X2, colour=X3)) + geom_point()
}
```

## Simple adaptive design (for ICTMC)


### Problem

Simulation:
```{r}
sim_trial <- function(design, hypothesis)
{
  design <- as.numeric(design); hypothesis <- as.numeric(hypothesis)
  
  n <- design[1]; np <- design[2]
  a1 <- design[3]; a2 <- design[4]
  
  mu <- hypothesis[1]; sig <- hypothesis[2]
  
  n1 <- n*np; n2 <- n - n1
  
  x1 <- mean(rnorm(n1, mean = mu, sd = sig))
  x2 <- mean(rnorm(n2, mean = mu, sd = sig))
  x <- (n1*x1 + n2*x2)/(n1 + n2)
  
  g <- x1 > a1 & x > a2
  s <- !g
  n <- n1 + n2*(x1 > a1)
  
  return(c(g, s, n))
}

# For example,
sim_trial(c(300, 0.5, 0.4, 0.1), # design
          c(0.3, 1))    # hypothesis

out_dim <- 3
```

Deterministic objective functions:
```{r}
det_obj <- NULL
```

Design space and hypotheses:
```{r}
design_space <- data.frame(name=c("n", "np", "a1", "a2"), 
                           low=c(10,0,0,0), 
                           up=c(200,1,0.2,0.2)
)

hypotheses <- data.frame(mu=c(0, 0.3),
                     sig=c(1, 1))
```


### Initialisation

Constraints and objectives:

```{r}
constraints <- data.frame(name = c("a", "b"),
                   out_i = c(1, 2),
                   hyp_i = c(1, 2),
                   nom = c(0.2, 0.2),
                   delta =c(0.95, 0.95),
                   stoch = c(TRUE, TRUE))

objectives <- data.frame(name = c("f1", "f2", "f3"),
                 out_i = c(1, 2, 3),
                 hyp_i = c(1, 2, 1),
                 weight = c(100, 100, 1),
                 stoch = c(TRUE, TRUE, TRUE))

objectives$weight <- objectives$weight/sum(objectives$weight)
objectives$name <- as.character(objectives$name)
```

Initial DoE:

```{r}
size <- 40
N <- 1000

DoE <- init_DoE(size, design_space)

DoE <- cbind(DoE, t(apply(DoE, 1, calc_rates, hypotheses=hypotheses, N=N, sim=sim_trial)))
DoE$N <- N

to_model <- data.frame(out_i = c(1, 1, 2, 2, 3, 3),
                       hyp_i = c(1, 2, 1, 2, 1, 2))

mods <- fit_models(DoE, to_model, design_space, objectives, out_dim)
models <- mods[1:nrow(to_model)]
models_reint <- mods[(nrow(to_model)+1):length(mods)]

pf_out <- pareto_front(design_space, models, DoE, objectives, constraints, to_model, det_obj)
pf <- pf_out[[1]][,1:nrow(objectives)]
```

### Iteration

```{r}
traj <- NULL

for(i in 1:20){
  ptm <- proc.time()
  opt <- RcppDE::DEoptim(ehi_infill, lower=design_space$low, upper=design_space$up,
                                 control=list(trace=FALSE, itermax=100, reltol=1e-1, steptol=50),
                                 N=N, pf=pf, mod=mods, design_space=design_space, constraints=constraints,
                                 objectives=objectives, det_obj=det_obj, out_dim=3, to_model=to_model)
  sol <- as.numeric(opt$optim$bestmem)
  #sol[1:2] <- round(sol[1:2])
  print(proc.time() - ptm)
          
  y <- calc_rates(sol, hypotheses=hypotheses, N=N, sim=sim_trial)
  
  DoE <- rbind(DoE, c(sol, y, N))
  
  mods <- fit_models(DoE, to_model, design_space, objectives, out_dim)
  models <- mods[1:nrow(to_model)]
  models_reint <- mods[(nrow(to_model)+1):length(mods)]
  
  pf_out <- pareto_front(design_space, models, DoE, objectives, constraints, to_model, det_obj)
  pf <- pf_out[[1]][,1:nrow(objectives)]
  
  # choose ref point as worst objective val in each dimension
  ref <- c(1, 1, 1)
  current <- emoa::dominated_hypervolume(t(pf), ref)
  traj <- rbind(traj, c(-opt$optim$bestval, current))
}
```

### Presentation

```{r}
#saveRDS(DoE, "DoE.Rds")
DoE <- readRDS("DoE.Rds")

DoE_ps_is <- sapply(pf_out[[1]][,4], function(x) which(pf_out[[2]] == x))

df <- DoE[DoE_ps_is, ]

obj_v <- as.data.frame(predict_obj(df[,1:4], models, objectives, det_obj, to_model))
obj_v <- as.data.frame(t(t(obj_v)/objectives$weight))
obj_v$t <- ifelse(DoE_ps_is <= 40, "Initial", "Iterated")

ggplot(obj_v, aes(x=V1, y=V2, colour=V3, shape = t)) + geom_point() +
  xlab("Type I error rate") + ylab("Type II error rate") +
  scale_color_viridis(name="E[N]") +
  scale_shape(name = "")+#, labels("a", "b")) +
  theme_minimal() +
  theme(panel.grid.major=element_line(colour="grey50"),
        panel.grid.minor=element_line(colour="grey50"))

#ggsave(width = 6, height = 3, filename = "../Presentations/ICTMC 2022/results.png")
```

```{r}
df2 <- data.frame(exp_imp = traj[,1])
df2$i <- 1:40

ggplot(df2, aes(i, exp_imp)) +  geom_smooth(se=F, colour = "grey60") + geom_point() +
  xlab("Iteration") + ylab("Expected improvement") + 
  theme_minimal()

#ggsave(width = 6, height = 4, filename = "../Presentations/ICTMC 2022/traj.png")
```

## Adaptive design (NIFTy)

### Problem

Simulation:
```{r}
#n is the total sample size
#ninterim is the number of patients at the interim analysis (proportion)
#ainterim is alpha at interim analysis (threshold p-value at interim analysis)
#afinal is alpha at final analaysis (threshold p-value for 2nd and final analysis)
#this means overall alpha for the trial is ainterim*afinal
#
#pcontshort is the probability of 1 day PoSH in the control arm
#pexpshort is the probability of 1 day PoSH in the experimental arm
#pcontlong is the probability of 6 month PoSH in the control arm
#pexplong is the probability of 6 month PoSH in the experimental arm

sim_trial <- function(design, hypothesis)
{
  design <- as.numeric(design); hypothesis <- as.numeric(hypothesis)
  
  n <- design[1]; ninterim <- design[2]
  ainterim <- design[3]; afinal <- design[4]
  
  pcontshort <- hypothesis[1]; pexpshort <- hypothesis[2]
  pcontlong <- hypothesis[3]; pexplong <- hypothesis[4]
  
  ninterim <- floor(ninterim*n)
  
  patients<-c(1:n) #create patients
  treat<-rep(c(1,2),ceiling(n/2))[1:n] #assign to treatment 1 or 2
  
  short<-rep(0,n) #short term outcome
  long<-rep(0,n) #long term outcome
  
  data<-data.frame(patients,treat,short,long) #combine into dataset
  
  #generate result 1/0 for short term outcome. If short term outcome=0 then long term outcome=0
  #If short term outcome=1 then long term outcome has probability pcontlong/pcontshort
  #repeat for treatment=2
  for(i in 1:n){
    if(treat[i]==1){
      data$short[i]<-rbinom(1,1,pcontshort)
      if(data$short[i]==0){
        data$long[i]<-0
      }
      if(data$short[i]==1){
        data$long[i]<-rbinom(1,1,pcontlong/pcontshort)
      }
    }
    else{
      data$short[i]<-rbinom(1,1,pexpshort)
      if(data$short[i]==0){
        data$long[i]<-0
      }
      if(data$short[i]==1){
        data$long[i]<-rbinom(1,1,pexplong/pexpshort)
      }
    }
  }
  #perform chi squared test on short term outcome for 1st ninterim patients
  data2<-data[1:ninterim,]
  tbl<-table(data2$short,data2$treat)
  test<- suppressWarnings(chisq.test(tbl)$p.value) #get p-value
  
  #if p<ainterim, perform chi squared test on long term outcome for all patients
  if(test<ainterim){
    tbl2<-table(data$long,data$treat)
    test2<- suppressWarnings(chisq.test(tbl2)$p.value)
  }
  
  #if p>ainterim, trial unsuccessful at interim and final analysis
  #if p<ainterim, trial successful at interim:
  #if p2>afinal, trial unsuccessful at final analysis
  #if p2<afinal, trial successful at final analysis
  if(test>=ainterim){
    return(c(g = 0, s = 1, n = ninterim))
  }
  if(test<ainterim){
    if(mean(data2[data2$treat == 1,"short"]) < mean(data2[data2$treat == 2,"short"])){
      return(c(g = 0, s = 1, n = ninterim))
    } else {
      if(test2>afinal){
        return(c(g = 0, s = 1, n = n))
      }
      if(test2<afinal){
        return(c(g = 1, s = 0, n = n))
      }
    }
  }
}

# For example,
sim_trial(c(300, 0.5, 0.4, 0.1), # design
          c(0.25, 0.125, 0.1, 0.03))    # hypothesis

out_dim <- 3
```

Deterministic objective functions:
```{r}
det_obj <- NULL
```


Design space and hypotheses:
```{r}
design_space <- data.frame(name=c("n", "ninterim", "ainterim", "afinal"), 
                           low=c(100,0.05,0,0), 
                           up=c(800,0.5,1,1)
)

hypotheses <- data.frame(pcontshort=c(0.25, 0.25),
                     pexpshort=c(0.25, 0.125), 
                     pcontlong=c(0.25, 0.1),
                     pexplong =c(0.25, 0.03))
```


### Initialisation

Constraints and objectives:

```{r}
constraints <- data.frame(name = c("a", "b"),
                   out_i = c(1, 2),
                   hyp_i = c(1, 2),
                   nom = c(0.2, 0.2),
                   delta =c(0.95, 0.95),
                   stoch = c(TRUE, TRUE))

objectives <- data.frame(name = c("f1", "f2", "f3"),
                 out_i = c(1, 2, 3),
                 hyp_i = c(1, 2, 1),
                 weight = c(100, 100, 1),
                 stoch = c(TRUE, TRUE, TRUE))

objectives$weight <- objectives$weight/sum(objectives$weight)
objectives$name <- as.character(objectives$name)
```

Initial DoE:

```{r}
size <- 40
N <- 100

DoE <- init_DoE(size, design_space)

DoE <- cbind(DoE, t(apply(DoE, 1, calc_rates, hypotheses=hypotheses, N=N, sim=sim_trial)))
DoE$N <- N

to_model <- data.frame(out_i = c(1, 1, 2, 2, 3, 3),
                       hyp_i = c(1, 2, 1, 2, 1, 2))

mods <- fit_models(DoE, to_model, design_space, objectives, out_dim)
models <- mods[1:nrow(to_model)]
models_reint <- mods[(nrow(to_model)+1):length(mods)]

pf_out <- pareto_front(design_space, models, DoE, objectives, constraints, to_model, det_obj)
pf <- pf_out[[1]]
```


### Iteration

```{r}
traj <- NULL

for(i in 1:20){
  ptm <- proc.time()
  opt <- RcppDE::DEoptim(ehi_infill, lower=design_space$low, upper=design_space$up,
                                 control=list(trace=FALSE, itermax=100, reltol=1e-1, steptol=50),
                                 N=N, pf=pf[,1:3], mod=mods, design_space=design_space, constraints=constraints,
                                 objectives=objectives, det_obj=det_obj, out_dim=out_dim, to_model=to_model)
  sol <- as.numeric(opt$optim$bestmem)
  #sol[1:2] <- round(sol[1:2])
  print(proc.time() - ptm)
          
  y <- calc_rates(sol, hypotheses=hypotheses, N=N, sim=sim_trial)

  DoE <- rbind(DoE, c(sol, y, N))
  
  mods <- fit_models(DoE, to_model, design_space, objectives, out_dim)

  pf_out <- pareto_front(design_space, models, DoE, objectives, constraints, to_model, det_obj)
  pf <- pf_out[[1]]
  
  #ref <- c(design_space$up, 1)*objectives$weight
  ref <- c(1,1,5)
  current <- emoa::dominated_hypervolume(t(pf[,1:3]), ref)
  traj <- rbind(traj, c(-opt$optim$bestval, current))
}
```

### Presentation

```{r}
# Get the Pareto set
DoE <- cbind(DoE, pf_out[[2]])
ps <- DoE[sapply(pf[,4], function(x) which(DoE[,ncol(DoE)] == x)),]

ps <- ps[, c(5, 13, 9)]

if(ncol(ps) == 2){
  df <- data.frame(ps)
  ggplot(df, aes(x=X1, y=X2)) + geom_point()
} else if(ncol(ps) == 3){
  df <- data.frame(ps)
  ggplot(df, aes(x=g_m_1, y=s_m_2, colour=n_m_1)) + geom_point()
}
```

## Bayesian / decision theoretic multilevel model

## Multi-state models


